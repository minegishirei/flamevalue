<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>D3.js_demo</title>
    <link rel="stylesheet" href="style.css">
    <!--    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.1.1/d3.js"></script>-->
</head>

<body>
    <svg style="background-color:#231f20">
    </svg>
    <style>
        svg {
            width: 100%;
            height: 10000px;
        }
        body {
            background-color: #231f20;
        }
    </style>
    <script src="https://d3js.org/d3.v4.min.js"></script>

    <script>
        var R = 25
        var svg = d3.select("svg"),
            width = +svg.attr("width"),
            height = +svg.attr("height");
        
            
        var color = d3.scaleOrdinal()
            .range(["#f7d147", "#03a6a6", "#fe736c", "#ec5a31", "#d8345f", "#a7d129", "#f8eeb4", "#fe736c", "#616f39", "#ff6363", "#a7d129", "#d8345f", "#db2ae2"]);

        var simulation = d3.forceSimulation()
            .velocityDecay(0.4) //摩擦
            .force('charge', d3.forceManyBody()) //詳細設定は後で
            .force('link', d3.forceLink().id(function (d) {
                return d.name;
            })) //詳細設定は後で
            .force('colllision', d3.forceCollide(40)) //nodeの衝突半径：Nodeの最大値と同じ
            .force('positioningX', d3.forceX()) //詳細設定は後で
            .force('positioningY', d3.forceY()) //詳細設定は後で
            .force('center', d3.forceCenter(width / 2, height / 2)); //重力の中心
        
        //"svg"にZoomイベントを設定
        var zoom = d3.zoom()
            .scaleExtent([1 / 4, 4])
            .on('zoom', SVGzoomed);

        svg.call(zoom);

        //"svg"上に"g"をappendしてdragイベントを設定
        var g = svg.append("g")
            .call(d3.drag()
                .on('drag', SVGdragged))

        function SVGzoomed() {
            g.attr("transform", d3.event.transform);
        }

        function SVGdragged(d) {
            d3.select(this).attr('cx', d.x = d3.event.x).attr('cy', d.y = d3.event.y);
        };

        d3.json("https://raw.githubusercontent.com/kawadasatoshi/twitter_network/main/{{ acount_name }}", function (error, graph) {
            if (error) throw error;


            var link = g.append("g") //svg⇒gに
                .attr("class", "links")
                .selectAll("line")
                .data(graph.links)
                .enter().append("line")
                .attr("stroke", "#666666") //輪郭線の色指定追加
                .attr("stroke-width", function (d) {
                    return Math.sqrt(d.value*10);
                });

            // nodeの定義
            var node = g.append('g')
                .attr('class', 'nodes')
                .selectAll('g')
                .data(graph.nodes)
                .enter()
                .append('g')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            //.on('click', function(){d3.select(this).attr('fill', 'red')}) //今はとりあえずnodeを赤くするという処理を書いているが、ここでクリックしたnodeに向かってカメラがズームするようなアニメーションをつけたい！！

            node.append("svg:image")
                .attr("xlink:href", function (d) { return d.img; })
                .attr("height", R*2)
                .attr("width", R*2)
                .attr('clip-path', 'url(#clip)')
                .attr("x", function (d) { return -R; })
                .attr("y", function (d) { return -R; });

            //図形判定
            function nodeTypeID(d) {
                var nodetype
                var arrRect = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0]

                if (arrRect.indexOf(d) >= 0) {
                    //Rect
                    return "rect"
                } else {
                    //Circle
                    return "circle"
                }
            }

            var Defs = svg.append("defs");
            
            var circles = Defs
                .append('circle')
                .attr('id', 'circle')
                .attr('r', R)
                .attr('cx', 0)
                .attr('cy', 0);

            Defs.append('clipPath')
                .attr('id', 'clip')
                .append('use')
                .attr('xlink:href', '#circle');

            simulation
                .nodes(graph.nodes)
                .on("tick", ticked);

            simulation.force("link")
                .links(graph.links);

            simulation.force('charge')
                .strength(function (d) {
                    return -1000
                }) //node間の力

            simulation.force('positioningX') //X方向の中心に向けた引力
                .strength(0.3)

            simulation.force('positioningY') //Y方向の中心に向けた引力
                .strength(0.3)

            function ticked() {
                link
                    .attr("x1", function (d) {
                        return d.source.x;
                    })
                    .attr("y1", function (d) {
                        return d.source.y;
                    })
                    .attr("x2", function (d) {
                        return d.target.x;
                    })
                    .attr("y2", function (d) {
                        return d.target.y;
                    });

                node
                    .attr("cx", function (d) {
                        return d.x;
                    })
                    .attr("cy", function (d) {
                        return d.y;
                    })
                    .attr('transform', function (d) {
                        return 'translate(' + d.x + ',' + d.y + ')'
                    }); //nodesの要素が連動して動くように設定
            }
        });

        function dragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function dragended(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    </script>



</body>

</html>